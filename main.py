# -*- coding: utf-8 -*-
"""Main

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1N20VQaYIPuEmDU3FhcjIeyFmmH1mzCvS
"""

# main.py
from fastapi.middleware.cors import CORSMiddleware

from fastapi import FastAPI
from pydantic import BaseModel
from transformers import AutoTokenizer, AutoModelForSequenceClassification, pipeline
from sklearn.feature_extraction.text import TfidfVectorizer

# === NLP-mallin alustaminen ===
tokenizer = AutoTokenizer.from_pretrained("nisancoskun/bert-finnish-sentiment-analysis")
model = AutoModelForSequenceClassification.from_pretrained("nisancoskun/bert-finnish-sentiment-analysis")
sentiment_pipeline = pipeline("sentiment-analysis", model=model, tokenizer=tokenizer)

# === Label mapping ===
label_map = {
    "LABEL_0": "NEGATIVE",
    "LABEL_1": "POSITIVE",
    "LABEL_2": "NEUTRAL"
}

# === FastAPI-sovellus ===
app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # tai ["*"] testikäytössä
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# === Syötemalli ===
class FeedbackInput(BaseModel):
    text: str

class FeedbackBatchRequest(BaseModel):
    feedbacks: list[str]


# === Aiheteemojen tunnistus ===
def detect_topic(text):
    themes = {
        "liikenne": ["tie", "katu", "bussi", "liikenne"],
        "terveys": ["terveys", "lääkäri", "hoitaja", "sairaala"],
        "koulutus": ["koulu", "opetus", "päiväkoti"],
        "palvelut": ["palvelu", "asiakaspalvelu", "virasto", "asiointi"]
    }
    for topic, keywords in themes.items():
        if any(word in text.lower() for word in keywords):
            return topic
    return "yleinen"

# === TF-IDF avainsanojen poiminta (yksinkertaistettu) ===
def extract_keywords(feedbacks, top_n=5):
    vectorizer = TfidfVectorizer(stop_words=None)
    tfidf_matrix = vectorizer.fit_transform(feedbacks)
    feature_names = vectorizer.get_feature_names_out()
    keywords_list = []
    for row in tfidf_matrix:
        row_data = row.toarray().flatten()
        top_indices = row_data.argsort()[-top_n:][::-1]
        keywords = [feature_names[i] for i in top_indices]
        keywords_list.append(keywords)
    return keywords_list

# === Täydellinen analyysi-funktio ===
def full_analysis(text, all_feedbacks=None):
    result = sentiment_pipeline(text)[0]
    label = label_map.get(result["label"], result["label"])
    score = round(result["score"], 4)
    topic = detect_topic(text)
    if all_feedbacks is None:
        all_feedbacks = [text]
    keywords_list = extract_keywords(all_feedbacks)
    keywords = keywords_list[0] if keywords_list else []
    summary = (
        f"Palaute on sävyltään {label.lower().replace('positive','positiivinen').replace('negative','negatiivinen').replace('neutral','neutraali')} "
        f"(varmuus {score*100:.1f} %) ja liittyy aiheeseen: {topic}."
    )
    return {
        "text": text,
        "sentiment": label,
        "sentiment_score": score,
        "topic": topic,
        "keywords": keywords,
        "summary": summary
    }

# === Endpointit ===
@app.get("/health")
def health():
    return {"status": "ok"}

@app.post("/analyze")
def analyze_feedback(input: FeedbackInput):
    analysis = full_analysis(input.text)
    return analysis

@app.post("/batch_analyze")
def batch_analyze(request: FeedbackBatchRequest):
    feedbacks = request.feedbacks

    results = {
        "total": len(feedbacks),
        "positive": 0,
        "negative": 0,
        "neutral": 0,
        "summaries": []
    }

    for text in feedbacks:
        analysis = full_analysis(text, all_feedbacks=feedbacks)
        label = analysis["sentiment"].upper()

        if label == "POSITIVE":
            results["positive"] += 1
        elif label == "NEGATIVE":
            results["negative"] += 1
        else:
            results["neutral"] += 1

        results["summaries"].append(analysis["summary"])

    def percentage(count):
        return round(100 * count / results["total"], 1) if results["total"] > 0 else 0.0

    return {
        "total_feedbacks": results["total"],
        "positive_percent": percentage(results["positive"]),
        "negative_percent": percentage(results["negative"]),
        "neutral_percent": percentage(results["neutral"]),
        "summary_sentences": results["summaries"]
    }
